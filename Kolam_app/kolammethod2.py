# -*- coding: utf-8 -*-
"""KolamMethod2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xGQwzhxEfauxZvkow7_cjOt3MRZwVuOB
"""

# ==================== SETUP: PASTE THIS ENTIRE BLOCK INTO ONE CELL AND RUN IT ====================
# This is the entire kolam_tool.py script

import os
import json
import argparse
import zipfile
import math
import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.path import Path
from matplotlib.patches import PathPatch

# -------------------------------------------------------------------
# Grid model
# -------------------------------------------------------------------
class DotGrid:
    def __init__(self, rows, cols, spacing=1.0, jitter=0.0):
        self.rows = int(rows)
        self.cols = int(cols)
        self.spacing = float(spacing)
        self.jitter = float(jitter)

    def points_array(self):
        rs = np.arange(self.rows, dtype=float) * self.spacing
        cs = np.arange(self.cols, dtype=float) * self.spacing
        yy, xx = np.meshgrid(rs, cs, indexing="ij")
        pts = np.stack([xx, yy], axis=-1) # (rows, cols, 2)
        if self.jitter > 0:
            pts = pts + (np.random.rand(*pts.shape) - 0.5) * 2 * self.jitter
        # center
        center = pts.mean(axis=(0,1), keepdims=True)
        pts = pts - center
        return pts

    def flat_points(self):
        P = self.points_array()
        r,c,_ = P.shape
        return [tuple(P[i,j]) for i in range(r) for j in range(c)]

    def bounds(self, margin=1.0):
        P = self.points_array()
        xmin = float(P[...,0].min()) - margin
        xmax = float(P[...,0].max()) + margin
        ymin = float(P[...,1].min()) - margin
        ymax = float(P[...,1].max()) + margin
        return xmin, xmax, ymin, ymax

# -------------------------------------------------------------------
# Rulebooks (generator functions)
# Each function returns a list of polylines (list of (x,y))
# -------------------------------------------------------------------
def gen_sikku_like(P):
    # P is (rows,cols,2)
    rows, cols, _ = P.shape
    paths = []
    # diamonds around each dot
    if rows*cols == 0:
        return paths
    # estimate spacing
    sx = np.median(np.diff(P[0,:,0])) if cols>1 else 1.0
    sy = np.median(np.diff(P[:,0,1])) if rows>1 else 1.0
    rx = sx * 0.35
    ry = sy * 0.35
    for i in range(rows):
        for j in range(cols):
            x,y = P[i,j]
            loop = [(x, y-ry), (x+rx, y), (x, y+ry), (x-rx, y), (x, y-ry)]
            paths.append(loop)
    # connectors
    for i in range(rows):
        for j in range(cols-1):
            p = P[i,j]; q = P[i,j+1]
            mid = (p+q)/2
            ctrl = tuple((mid + np.array([0, (ry+rx)*0.5])).tolist())
            paths.append([ (float(p[0]+rx), float(p[1])), ctrl, (float(q[0]-rx), float(q[1])) ])
    for i in range(rows-1):
        for j in range(cols):
            p = P[i,j]; q = P[i+1,j]
            mid = (p+q)/2
            ctrl = tuple((mid + np.array([ (ry+rx)*0.5, 0 ])).tolist())
            paths.append([ (float(p[0]), float(p[1]+ry)), ctrl, (float(q[0]), float(q[1]-ry)) ])
    return paths

def gen_2x2_loops(P):
    rows, cols, _ = P.shape
    paths = []
    for i in range(rows-1):
        for j in range(cols-1):
            a = P[i,j]; b = P[i,j+1]; c = P[i+1,j+1]; d = P[i+1,j]
            # midpoints
            m_ab = (a+b)/2; m_bc = (b+c)/2; m_cd = (c+d)/2; m_da = (d+a)/2
            # outward normals scaled
            def normal(p,q,scale=0.3):
                v = q - p
                n = np.array([-v[1], v[0]])
                nlen = np.linalg.norm(n)
                if nlen < 1e-9:
                    return ((p+q)/2).tolist()
                n = n / nlen
                return ((p+q)/2 + n*scale).tolist()
            ctrl1 = normal(a,b)
            ctrl2 = normal(b,c)
            ctrl3 = normal(c,d)
            ctrl4 = normal(d,a)
            loop = [tuple(m_ab.tolist()), tuple(ctrl2), tuple(m_bc.tolist()), tuple(ctrl3),
                    tuple(m_cd.tolist()), tuple(ctrl4), tuple(m_da.tolist()), tuple(ctrl1), tuple(m_ab.tolist())]
            paths.append(loop)
    return paths

def gen_weave(P):
    rows, cols, _ = P.shape
    paths = []
    r = (np.linalg.norm(P[0,1]-P[0,0])/3.0) if cols>1 else 0.2
    for i in range(rows):
        for j in range(cols):
            p = P[i,j]
            if j+1 < cols:
                q = P[i,j+1]
                mid = (p+q)/2
                ctrl = (mid + np.array([0, r])).tolist()
                paths.append([tuple(p.tolist()), tuple(ctrl), tuple(q.tolist())])
            if i+1 < rows:
                q = P[i+1,j]
                mid = (p+q)/2
                ctrl = (mid + np.array([r, 0])).tolist()
                paths.append([tuple(p.tolist()), tuple(ctrl), tuple(q.tolist())])
    return paths

RULEBOOKS = {
    "sikku_like": gen_sikku_like,
    "2x2_loops": gen_2x2_loops,
    "weave": gen_weave
}

# -------------------------------------------------------------------
# Renderer (matplotlib)
# -------------------------------------------------------------------
def draw_smooth_curve(ax, pts, linewidth=1.6):
    pts = np.asarray(pts, dtype=float)
    if len(pts) < 2:
        return
    verts = []
    codes = []
    verts.append(tuple(pts[0])); codes.append(Path.MOVETO)
    for i in range(1, len(pts)):
        # use quadratic bezier (CURVE3) with ctrl = mid point of previous and current
        ctrl = ((pts[i-1] + pts[i]) / 2.0).tolist()
        verts.append(tuple(ctrl)); codes.append(Path.CURVE3)
        verts.append(tuple(pts[i])); codes.append(Path.CURVE3)
    path = Path(verts, codes)
    patch = PathPatch(path, fill=False, lw=linewidth)
    ax.add_patch(patch)

def render_to_png(paths, dot_positions, out_path, figsize=(6,6), show_dots=True, dotsize=20):
    fig = plt.figure(figsize=figsize)
    ax = fig.add_subplot(111, aspect="equal")
    ax.axis("off")
    if show_dots:
        P = np.array(dot_positions)
        ax.scatter(P[:,0], P[:,1], s=dotsize, zorder=3)
    for poly in paths:
        draw_smooth_curve(ax, poly)
    # autoscale
    allx=[]; ally=[]
    for poly in paths:
        for x,y in poly:
            allx.append(x); ally.append(y)
    if allx and ally:
        pad = 1.0
        ax.set_xlim(min(allx)-pad, max(allx)+pad)
        ax.set_ylim(min(ally)-pad, max(ally)+pad)
    fig.savefig(out_path, bbox_inches="tight", pad_inches=0.02)
    plt.close(fig)

# -------------------------------------------------------------------
# Rasterize & analysis
# -------------------------------------------------------------------
def rasterize_paths(paths, bounds, size=256):
    xmin, xmax, ymin, ymax = bounds
    W = H = size
    canvas = np.zeros((H,W), dtype=np.uint8)
    for poly in paths:
        pts = np.asarray(poly, dtype=float)
        if len(pts) == 0:
            continue
        # map to pixel coordinates
        xs = ((pts[:,0] - xmin) / (xmax - xmin + 1e-12) * (W-1)).astype(int)
        ys = ((pts[:,1] - ymin) / (ymax - ymin + 1e-12) * (H-1)).astype(int)
        for k in range(len(xs)-1):
            x0,y0 = xs[k], ys[k]; x1,y1 = xs[k+1], ys[k+1]
            n = max(abs(x1-x0), abs(y1-y0), 1)
            for t in range(n+1):
                x = int(round(x0 + (x1-x0)*t/(n+1e-9)))
                y = int(round(y0 + (y1-y0)*t/(n+1e-9)))
                if 0 <= x < W and 0 <= y < H:
                    canvas[y,x] = 255
    return canvas

def dice_similarity(a, b):
    a = (a>0); b = (b>0)
    inter = np.logical_and(a,b).sum()
    denom = a.sum()+b.sum()
    if denom == 0:
        return 1.0 if inter==0 else 0.0
    return float((2*inter)/(denom+1e-12))

def analyze_symmetry(paths, bounds, img_size=256):
    img = rasterize_paths(paths, bounds, img_size)
    results = {}
    # rotational
    results["rot_90"] = dice_similarity(img, np.rot90(img, 1))
    results["rot_180"] = dice_similarity(img, np.rot90(img, 2))
    results["rot_270"] = dice_similarity(img, np.rot90(img, 3))
    # reflections
    results["reflect_horizontal"] = dice_similarity(img, img[:, ::-1])
    results["reflect_vertical"] = dice_similarity(img, img[::-1, :])
    # diagonal reflections (approx)
    results["reflect_diag_main"] = dice_similarity(img, np.rot90(img[:, ::-1], 1))
    results["reflect_diag_anti"] = dice_similarity(img, np.rot90(img[:, ::-1], 3))
    return results

def analyze_strokes(paths):
    num_paths = len(paths)
    curvatures = []
    for poly in paths:
        p = np.asarray(poly, dtype=float)
        if p.shape[0] < 3:
            continue
        v = p[1:] - p[:-1]
        norms = np.linalg.norm(v, axis=1) + 1e-12
        u = v / norms[:,None]
        ang = 0.0
        for i in range(len(u)-1):
            dot = np.clip(np.dot(u[i], u[i+1]), -1.0, 1.0)
            ang += math.acos(dot)
        curvatures.append(ang)
    avg_curv = float(np.mean(curvatures)) if curvatures else 0.0
    return {"num_strokes": int(num_paths), "avg_total_turn_radians": float(avg_curv)}

print("✅ Setup complete! All functions (sikku_like, 2x2_loops, weave) are now defined.")

# ==================== GENERATE A KOLAM: PASTE THIS INTO A NEW CELL ====================

# Set your parameters here (THIS IS WHAT YOU CHANGE!)
rows = 9
cols = 9
rule = "sikku_like"  # Try "2x2_loops" or "weave" too!
output_filename = "my_kolam.png"
show_dots = True
run_analysis = True

# -------- Don't change the code below --------
# This part uses the parameters above to generate the image.

grid = DotGrid(rows, cols, spacing=1.0)
P_arr = grid.points_array()
flat_pts = grid.flat_points()

paths = RULEBOOKS[rule](P_arr)

render_to_png(paths, flat_pts, output_filename, show_dots=show_dots)


# Run analysis if requested
if run_analysis:
    print("\n🔍 Analysis Results:")
    bounds = grid.bounds(margin=1.0)
    symmetry_results = analyze_symmetry(paths, bounds)
    stroke_results = analyze_strokes(paths)
    print("Symmetry:")
    print(json.dumps(symmetry_results, indent=2))
    print("\nStrokes:")
    print(json.dumps(stroke_results, indent=2))

print(f"\n✅ Done! Image saved as '{output_filename}'")

# ==================== DOWNLOAD YOUR IMAGE ====================


